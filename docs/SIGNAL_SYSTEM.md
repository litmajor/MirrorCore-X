
# Signal System Documentation

## Overview

The MirrorCore-X trading system generates signals through multiple layers:
1. **Scanner Signals** - Traditional technical analysis
2. **Enhanced Signals** - Multi-timeframe, mean reversion, regime detection
3. **RL Signals** - Reinforcement learning predictions
4. **Meta-Controller Signals** - Blended final decisions

## Signal Types and Their Lifecycle

### 1. Traditional Scanner Signals

**Generated by**: `scanner.py` → `SignalClassifier.classify_momentum_signal()`

**Signal Types**:
- `Strong Buy` - High momentum, bullish indicators aligned
- `Buy` - Positive momentum, favorable conditions
- `Weak Buy` - Slight bullish bias
- `Neutral` - No clear direction
- `Weak Sell` - Slight bearish bias
- `Sell` - Negative momentum, bearish conditions
- `Strong Sell` - Strong downward momentum

**Frequency**: 
- Depends on timeframe:
  - `scalping`: 1-minute intervals
  - `short`: 5-minute intervals
  - `medium`: 1-hour intervals
  - `daily`: Daily (default)
  - `weekly`: Weekly

**Lifecycle**:
1. Market data fetched via `MarketDataFetcher`
2. Technical indicators calculated (`TechnicalIndicators.add_all_indicators()`)
3. Momentum metrics computed (short/long period)
4. Signal classified based on thresholds in `TradingConfig.signal_thresholds`
5. Confidence score assigned (`calculate_confidence_score()`)
6. Results stored in `scanner.scan_results` DataFrame

**Key Columns in Output**:
```python
{
    'symbol': str,
    'signal': str,  # Signal type
    'confidence_score': float,  # 0.0 - 1.0
    'composite_score': float,  # Weighted indicator score
    'momentum_short': float,
    'momentum_long': float,
    'rsi': float,
    'macd': float,
    'volume_ratio': float
}
```

### 2. Enhanced Signals (New Features)

**Generated by**: `scanner.py` → `_analyze_timeframe_signals()`

**Signal Types**:

#### A. Momentum Signals
- **Cluster-Validated Momentum**: Momentum confirmed by multiple indicators
  - `cluster_validated`: bool
  - `momentum_strength`: 'weak', 'moderate', 'strong'
  - `enhanced_momentum_score`: float (scaled 0-100)

#### B. Mean Reversion Signals
- **Reversion Candidates**: Overbought/oversold conditions
  - `reversion_candidate`: bool
  - `reversion_probability`: float (0.0 - 1.0)
  - `momentum_exhaustion`: bool
  - `excessive_gain`: bool (RSI > 70, declining momentum)
  - `excessive_loss`: bool (RSI < 30, rising momentum)

**Lifecycle**:
1. Detected when RSI extreme + momentum divergence
2. Probability calculated based on RSI distance + momentum delta
3. Signal may flip: "Strong Buy" → "Mean Reversion Sell"

#### C. Regime Signals
- **Volatility Regime**: Market volatility state
  - `volatility_regime`: 'low', 'normal', 'high'
  - `volatility_ratio`: float
  
- **Trend Regime**: Trend strength/direction
  - `trend_regime`: 'sideways', 'up', 'down', 'strong_up', 'strong_down'

**Lifecycle**:
1. Volume ratio analyzed (high vol: >1.5, low vol: <0.7)
2. EMA 50/200 crossover checked
3. Momentum slope evaluated
4. Regime classified and used to adjust confidence

#### D. Cluster Signals
- **Directional Clusters**: Candlestick pattern formations
  - `cluster_detected`: bool
  - `cluster_strength`: float (0.0 - 1.0)
  - `directional_cluster`: bool
  - `trend_formation_signal`: bool

**Example Pattern**: Bullish engulfing
```python
if (prev_candle bullish and 
    curr_candle bullish and 
    curr_candle closes higher and
    curr_candle body > prev_candle body * 1.2):
    # Cluster detected, potential trend formation
```

### 3. Multi-Timeframe Confluence Signals

**Generated by**: `scanner.py` → `scan_multi_timeframe()`

**Signal Types**:
- `multi_tf_confirmed`: bool (all timeframes agree)
- `confluence_signal`: Most common signal across timeframes
- `confluence_zone`: Count of agreeing timeframes
- `strong_confluence`: All timeframes identical

**Lifecycle**:
1. Scan multiple timeframes (e.g., '1h', '4h', '1d')
2. Find common symbols across all timeframes
3. Collect signals from each timeframe
4. Check for bullish/bearish/neutral alignment
5. Calculate confluence strength

**Frequency**: On-demand via `scan_multi_timeframe()` call

### 4. RL (Reinforcement Learning) Signals

**Generated by**: `rl_trading_system.py` → `RLTradingAgent.predict()`

**Signal Type**:
- Continuous position size: `-1.0` (max short) to `+1.0` (max long)
- `rl_position`: float

**Lifecycle**:
1. Market features encoded via `SignalEncoder`
2. Observation normalized (20 timesteps × 21 features)
3. RL model predicts optimal position
4. Action clipped to [-1.0, 1.0] range

**Training Frequency**: 
- Configurable via `RLConfig.total_timesteps` (default: 100,000)
- Evaluation every `eval_freq` steps (default: 5,000)

**Model Types**:
- PPO (Proximal Policy Optimization) - default
- SAC (Soft Actor-Critic)
- A2C (Advantage Actor-Critic)

### 5. Meta-Controller Final Signals

**Generated by**: `rl_trading_system.py` → `MetaController.decide()`

**Signal Types**:
- `final_position`: Blended position size (-1.0 to 1.0)
- `method`: Decision method used

**Methods**:
- `rule_based`: 100% traditional signal
- `reinforcement_learning`: 100% RL signal
- `rl_weighted`: 70% RL, 30% rule (high confidence)
- `balanced`: 50/50 blend (medium confidence)
- `rule_weighted`: 30% RL, 70% rule (low confidence)
- `trend_adaptive`: Regime-based (80% RL in trends)
- `volatility_adaptive`: Regime-based (80% rule in volatility)

**Lifecycle**:
1. Receive traditional signal (e.g., "Buy")
2. Convert to position size via `_rule_to_position()`
3. Get RL position from trained agent
4. Blend based on:
   - `confidence_score` (0.0 - 1.0)
   - `market_regime` ('normal', 'trending', 'volatile')
5. Clip final position to [-1.0, 1.0]
6. Store in `performance_history`

## Signal Flow Diagram

```
Market Data (CCXT/yfinance)
    ↓
MarketDataFetcher.fetch_ohlcv()
    ↓
TechnicalIndicators.add_all_indicators()
    ↓
┌─────────────────────────────────────┐
│  Traditional Signal Classification  │
│  - SignalClassifier.classify_       │
│    momentum_signal()                │
│  - classify_state() (new)           │
│  - classify_legacy()                │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│  Enhanced Signal Analysis           │
│  - _analyze_timeframe_signals()     │
│  - Momentum validation              │
│  - Mean reversion detection         │
│  - Regime classification            │
│  - Cluster patterns                 │
└─────────────────────────────────────┘
    ↓
scanner.scan_results DataFrame
    ↓
┌─────────────────────────────────────┐
│  RL Signal Generation (if trained)  │
│  - SignalEncoder.encode()           │
│  - RLTradingAgent.predict()         │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│  Meta-Controller Blending           │
│  - MetaController.decide()          │
│  - Confidence-based weighting       │
│  - Regime adaptation                │
└─────────────────────────────────────┘
    ↓
Final Trading Signal
    ↓
ExecutionDaemon (execute trades)
```

## Signal Retrieval Methods

### Get Strong Signals
```python
# Get high-quality signals (composite score >= 70)
strong_signals = scanner.get_strong_signals(
    timeframe='daily',
    min_score=70.0
)
```

### Get Mean Reversion Candidates
```python
# Get overbought/oversold opportunities
reversion_signals = scanner.get_reversion_candidates(
    timeframe='daily'
)
# Sorted by reversion_probability descending
```

### Get Cluster-Validated Momentum
```python
# Get momentum signals validated by clusters
cluster_momentum = scanner.get_cluster_validated_momentum(
    timeframe='daily'
)
```

### Get Multi-Timeframe Signals
```python
# Scan multiple timeframes for confluence
mtf_signals = scanner.scan_multi_timeframe(
    timeframes=['1h', '4h', '1d'],
    full_analysis=True
)
# Filter for confirmed signals
confirmed = mtf_signals[mtf_signals['multi_tf_confirmed'] == True]
```

## Signal Frequency by Component

| Component | Frequency | Trigger |
|-----------|-----------|---------|
| Scanner Traditional | User-initiated | `scan_market()` call |
| Scanner Enhanced | User-initiated | `scan_market()` call |
| Multi-Timeframe | User-initiated | `scan_multi_timeframe()` call |
| RL Prediction | Per-symbol on scan | When RL agent trained |
| Meta-Controller | Per trading session | `execute_trading_session()` |

## Signal Persistence

### Storage
- **In-Memory**: `scanner.scan_results` DataFrame
- **CSV Export**: Auto-saved to `scan_results_{timeframe}_{timestamp}.csv`
- **Trading History**: `IntegratedTradingSystem.trading_history` list

### Retrieval
```python
# Latest scan results
df = scanner.scan_results

# Specific timeframe filter
daily_signals = df[df['timeframe'] == 'daily']

# Export to CSV
scanner.scan_results.to_csv('my_signals.csv', index=False)
```

## Advanced Signal Features

### 1. Enhanced Scoring
```python
enhanced_score = (
    composite_score +
    enhanced_momentum_score * 10 +
    cluster_validated * 5 +
    reversion_probability * 15 +
    trend_formation_signal * 8
)
```

### 2. Confidence Calibration
- Base confidence from traditional indicators
- Boosted by:
  - `cluster_validated`: +0.2
  - `trend_formation_signal`: +0.15
  - `enhanced_momentum_score > 0.03`: +0.1
  - `momentum_strength == 'strong'`: +0.1
  - `reversion_probability > 0.7`: +0.2
- Adjusted by regime:
  - High volatility: ×0.8
  - Low volatility: ×1.1

### 3. Signal Flipping (Mean Reversion)
When `reversion_probability > 0.7`:
- `Strong Buy` → `Mean Reversion Sell`
- `Strong Sell` → `Mean Reversion Buy`

## Integration with Other Systems

### Strategy Trainer
```python
# Strategies evaluate scanner signals
result = strategy.evaluate(scanner.scan_results)
# Returns signal score for weighting
```

### Trade Analyzer
```python
# Records executed trades from signals
analyzer.record_trade({
    'symbol': signal['symbol'],
    'signal_type': signal['signal'],
    'entry': signal['price'],
    'pnl': realized_pnl
})
```

### Additional Strategies Ensemble
```python
# Additional strategies process scanner data
from additional_strategies import run_all_strategies_and_ensemble

consensus = run_all_strategies_and_ensemble(
    scanner.scan_results,
    weights={'MEAN_REVERSION': 1.5, ...}
)
# Returns ensemble consensus per symbol
```

## Best Practices

1. **Multi-Timeframe Confirmation**: Use `scan_multi_timeframe()` for high-confidence trades
2. **Reversion + Momentum**: Check both for complementary opportunities
3. **Regime Awareness**: Adjust strategy based on `volatility_regime` and `trend_regime`
4. **Cluster Validation**: Prioritize `cluster_validated` momentum signals
5. **Confidence Thresholds**: Filter signals by `confidence_score >= 0.7` for quality
6. **Meta-Controller**: Use blended signals for risk-adjusted positioning

## Troubleshooting

### No Signals Generated
- Check `min_volume_usd` threshold (default: 500,000)
- Verify market data connectivity
- Review `signal_thresholds` in config

### Low Confidence Scores
- Increase `lookback_window` for more data
- Adjust threshold parameters in `TradingConfig`
- Check for conflicting indicators

### RL Agent Not Contributing
- Ensure agent is trained: `rl_agent.is_trained == True`
- Verify observation shape (20, 21)
- Check model path and loading

## Configuration Examples

### Conservative (High Confidence Only)
```python
config = TradingConfig(
    signal_thresholds={
        'crypto': {
            'daily': {
                'momentum_short': 0.08,  # Higher threshold
                'rsi_min': 40,           # Tighter range
                'rsi_max': 60
            }
        }
    }
)
```

### Aggressive (More Signals)
```python
config = TradingConfig(
    signal_thresholds={
        'crypto': {
            'daily': {
                'momentum_short': 0.03,  # Lower threshold
                'rsi_min': 25,           # Wider range
                'rsi_max': 75
            }
        }
    }
)
```

## API Reference

See individual module documentation:
- `scanner.py`: Traditional + Enhanced signals
- `rl_trading_system.py`: RL + Meta-controller
- `additional_strategies.py`: Ensemble signals
- `strategy_trainer_agent.py`: Strategy evaluation
